# 马拉车算法  
算法目的：为了更好的解决字符串的最长回文串问题  
算法精髓：马拉车算法的精髓就是把之前匹配过的字符串结果放到后面来使用  

算法思路：  
1.输入的字符串长度要么是**单数**，要么是**双数**，为了便于确定中间轴，将字符串长度变为单数，然后维护一个数组，该数组的长度等于改变长度后字符串的长度，用来存放对应位置的字符为轴的最长回文串长度。  
2.从第一个字符开始，向两端延伸，判断两端是否相同来确定回文长度，但是有些字符可能是它之前以某个字符为轴的回文串内的字符，那么此时便可以用马拉车算法，减少判断的次数。  
---
下面详细描述该算法的过程：  
1.预处理  
回文有奇偶长度两种情况，通过补充间隔符可以将这两种情况化简为奇数长度。
比如<kbd>ABA</kbd>补充为<kbd>#A#B#A#</kbd>中点还是B，<kbd>ABBA</kbd>补充为<kbd>#A#B#B#A#</kbd>中点为<kbd>#</kbd>，最后可以去掉。最后在两侧补上哨兵点方便停止遍历。  
2.计算数组长度  
&emsp;2.1朴素计算方法  
&emsp;&emsp;以一个中心计算回串，最直接的方法当然是左右遍历对比了，比如以i为中心：
```js
    lens[i] = 0
    while (arr[i + lens[i] + 1] == arr[i - lens[i] - 1]) {
        lens[i] += 1
    }
```
&emsp;&emsp;这个就是计算长度基本方式。n 个点，每个点最多计算 n/2遍，所以是n平方复杂度。  
&emsp;2.2朴素计算法优化  
&emsp;&emsp;由于我们是从左往右枚举马拉车，所以从<kbd>0~i</kbd>的所有数的最长半径都已经做出来了，是可用的,<kbd>0~i+lens[i]</kbd>就是我们已知的最大范围  
![alt](./malache1.png)    
&emsp;&emsp;在上述的基础上，我们已知在<kbd>i-lens[i]~i+lens[i]</kbd>范围内是回文，那么此时在<kbd>i~i+lens[i]</kbd>的范围内，都可以参考对应的<kbd>i~i-lens[i]</kbd>对应的轴回文长度，这样可以省去重新进行朴素计算法。比如：  
![alt](./malache2.png)    
&emsp;&emsp;此时要求的<kbd>lens[j]</kbd>，因为j对应的字符关于<kbd>i</kbd>对称，所以可以直接参考<kbd>lens[j-2]</kbd>的回文半径，当<kbd>j&lt;i+lens[i]</kbd>，那么直接参考对应的<kbd>lens[i*2-j]</kbd>，当<kbd>j&gt;i+lens[i]</kbd>，那么重新使用朴素计算法。

空间复杂度：插入分隔符形成新串，占用了线性的空间大小；<kbd>lens</kbd>数组也占用线性大小的空间，因此空间复杂度是线性的。  
时间复杂度：尽管代码里面有两层循环，通过朴素计算我们可以得出，Manacher的时间复杂度是线性的。由于内层的循环只对尚未匹配的部分进行，因此对于每一个字符而言，只会进行一次，因此时间复杂度是O(n)。